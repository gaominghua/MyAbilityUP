[toc]
#1.什么是多线程，进程和线程的区别？
1）进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。
2）线程(资源调度单位)是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。
<span><div style="text-align: center;">
![java并发-1](../picture/java并发/java并发-1.png)
</div></span>

#2.为什么要有多线程？
单线程：在单独的线程中依次执行每一个任务，效率是非常低下。
多线程：为每一个任务创建一个线程（无数量上限）。在请求规模为中等时，这种做法显然是更优秀的，因为相比一个线程轮询解决任务，为每个任务创建线程首先将同步变为异步，使得我们的服务可以在一个任务未完成时处理另一个任务，这提升了吞吐量。然后可以同时处理多个任务，这也提升了任务的处理效率。这么做的缺点在于资源管理困难，因为创建和关闭线程都有开销，线程要占用资源，线程能维持的数量也不是无限。
线程池：通过使用线程池，我们可以获得多线程的好处而避免难以管理的缺点，我们可以重用存在的线程，减少线程创建、消亡的开销，可以有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞

#3.进程和线程中共享的资源？以及线程独占的资源有哪些？
**共享资源**
1、进程申请的堆内存
2、进程打开的文件描述符
3、进程的全局数据(可用于线程之间通信)
4、进程ID、进程组ID
5、进程目录
6、信号处理器
**独占资源**
1、线程ID
同一进程中每个线程拥有唯一的线程ID。
2、寄存器组的值
由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线 程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。
3、线程堆栈
线程可以进行函数调用，必然会使用大函数堆栈。
4、错误返回码
线程执行出错时，必须明确是哪个线程出现何种错误，因此不同的线程应该拥有自己的错误返回码变量。
5、信号屏蔽码
由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。
6、线程的优先级
由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。
<span><div style="text-align: center;">
![java并发-2](../picture/java并发/java并发-2.png)
</div></span>

#4.进程通信有几种方式？
1.管道(pipe)及有名管道(named pipe)：
管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
2.信号(signal)：
信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
3.消息队列(message queue)：
消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
4.共享内存(shared memory)：
可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
5.信号量(semaphore)：
主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
6.套接字(socket)；
这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

#5.线程通信有几种方式？
1.Volatile关键字：线程之间相互通信采用共享内容的思想，当多个线程同时监听一个变量，当这个变量发生改变其他线程能够时刻感知到这个变量的变化。
2.Object类提供了线程间通信的方法：wait()、notify()、notifyaAl()，它们是多线程通信的基础，而这种实现方式的思想自然是线程间通信。
3.jdk1.5之后在java.util.concurrent包下提供了很多并发编程相关的工具类，简化了我们的并发编程代码的书写，***CountDownLatch***基于AQS框架，相当于也是维护了一个线程间共享变量state
4.LockSupport 是一种非常灵活的实现线程间阻塞和唤醒的工具，使用它不用关注是等待线程先进行还是唤醒线程先运行，但是得知道线程的名字。LockSupport.park();阻塞线程，LockSupport.unpark()唤醒线程

#6.线程创建有几种方式？
**1）继承Thread类（实现Runnable接口**
注意：线程开启不一定立即执行，由CPU调度执行
<span><div style="text-align: center;">
![java并发-3](../picture/java并发/java并发-3.png)
</div></span>

**2）实现Runnable接口（重要）**
<span><div style="text-align: center;">
![java并发-4](../picture/java并发/java并发-4.png)
![java并发-5](../picture/java并发/java并发-5.png)
![java并发-6](../picture/java并发/java并发-6.png)
</div></span>